# Fan-out / Fan-in

Напишите на Go программу, демонстрирующую паттерн **fan-out / fan-in**:  
параллельная обработка списка URL с ограничением одновременного количества горутин (воркеров), симуляция fetching через `time.Sleep`, сбор всех результатов в один канал.

## Требования

1. **Список URL**  
   Жёстко заданный список из 10–20 URL (можно просто строки вроде `"https://site1.com"`, `"https://site2.com"` и т.д.).

2. **Fan-out**  
   Запускайте горутины-воркеры для "загрузки" URL.  
   Количество одновременно работающих воркеров ограничено константой `MaxWorkers` (например, 4).

3. **Ограничение параллелизма**  
   Используйте семафор (через буферизованный канал или `sync.WaitGroup` + канал токенов),  
   чтобы в любой момент времени работало не более `MaxWorkers` горутин.

4. **Симуляция работы**  
   Каждая горутина "fetcher" симулирует загрузку через случайный `time.Sleep` от 100 мс до 1 секунды.  
   Результат — структура с URL и временем выполнения (в миллисекундах).

5. **Fan-in**  
   Все горутины отправляют результаты в **один общий канал** результатов.  
   В главной горутине собирайте результаты из этого канала и выводите их по мере поступления.

6. **Graceful shutdown**  
   - Ловите сигналы `SIGINT` / `SIGTERM` (Ctrl+C).
   - По сигналу прекращайте запуск новых задач.
   - Дождитесь завершения всех уже запущенных горутин.
   - Выведите все полученные результаты.
   - Программа должна завершиться чисто, без утечек горутин.

7. **Дополнительно (рекомендуется)**  
   - Используйте `context.Context` для передачи отмены в горутины (если задача началась — пусть завершится, новые не запускаем).
   - Выводите прогресс в реальном времени:  
     `Fetched https://site7.com in 432ms`  
   - В конце выведите общее время выполнения и количество обработанных URL.

8. **Требования к коду**  
   - Только стандартная библиотека.
   - Чистый, idiomatic Go.
   - Нет race condition, нет утечек горутин.

## Запуск

```bash
go run .